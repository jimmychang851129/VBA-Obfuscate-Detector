Filename     : ./macros/5f484a213cb069c72e31cdb2d90572a5e11e2ba1e2ee7540a46a6b08a033515f
OLE stream   : _VBA_PROJECT_CUR/VBA/Inet
VBA filename : Inet.cls
----------------------------------------
Attribute VB_Name = "Inet"
Attribute VB_Base = "0{FCFB3D2A-A0FA-1068-A738-08002B3371B5}"
Attribute VB_GlobalNameSpace = False
Attribute VB_Creatable = False
Attribute VB_PredeclaredId = True
Attribute VB_Exposed = False
Attribute VB_TemplateDerived = False
Attribute VB_Customizable = False
Option Explicit

#If VBA7 Or Win64 Then
    Private Declare PtrSafe Function DeleteUrlCacheEntry Lib "wininet" Alias "DeleteUrlCacheEntryA" (ByVal lpszUrlName As String) As Long
    Private Declare PtrSafe Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" (ByVal pCaller As LongPtr, ByVal szURL As String, ByVal szFileName As String, ByVal dwReserved As LongPtr, ByVal lpfnCB As LongPtr) As Long
    
    Private Declare PtrSafe Function InternetOpen Lib "wininet.dll" Alias "InternetOpenA" (ByVal sAgent As String, ByVal lAccessType As Long, ByVal sProxyName As String, ByVal sProxyBypass As String, ByVal lFlags As Long) As LongPtr
    Private Declare PtrSafe Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hOpen As LongPtr, ByVal sUrl As String, ByVal sHeaders As String, ByVal lLength As Long, ByVal lFlags As Long, ByVal lContext As Long) As LongPtr
    Private Declare PtrSafe Function InternetReadBinaryFile Lib "wininet.dll" Alias "InternetReadFile" (ByVal hfile As LongPtr, ByRef bytearray_firstelement As Byte, ByVal lNumBytesToRead As Long, ByRef lNumberOfBytesRead As Long) As LongLong
   ' VB6 -- Private Declare PtrSafe Function InternetReadBinaryFile Lib "wininet.dll" Alias "InternetReadFile" (ByVal hfile As LongPtr, ByVal BA As Byte(), ByVal lNumBytesToRead As Long, ByRef lNumberOfBytesRead As Long) As Long
    Private Declare PtrSafe Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As LongPtr) As Long
#Else
'   Declare Function DeleteUrlCacheEntry Lib "wininet" Alias "DeleteUrlCacheEntryA" (ByVal lpszUrlName As String) As Long
'   Declare Function URLDownloadToFile Lib "urlmon" Alias "URLDownloadToFileA" (ByVal pCaller As Long, ByVal szURL As String, ByVal szFileName As String, ByVal dwReserved As Long, ByVal lpfnCB As Long) As Long

'        Private Declare Function InternetOpenib "wininet.dll" Alias "InternetOpenA" (ByVal sAgent As String, ByVal lAccessType As Long, ByVal sProxyName As String, ByVal sProxyBypass As String, ByVal lFlags As Long) As Long
'        Private Declare Function InternetOpenUrl Lib "wininet.dll" Alias "InternetOpenUrlA" (ByVal hOpen As Long, ByVal sUrl As String, ByVal sHeaders As String, ByVal lLength As Long, ByVal lFlags As Long, ByVal lContext As Long) As Long
'        Private Declare Function InternetReadBinaryFile Lib "wininet.dll" Alias "InternetReadFile" (ByVal hfile As Long, ByRef bytearray_firstelement As Byte, ByVal lNumBytesToRead As Long, ByRef lNumberOfBytesRead As Long) As Long
'       ' VB6 -- Private Declare Function InternetReadBinaryFile Lib "wininet.dll" Alias "InternetReadFile" (ByVal hfile As LongPtr, ByVal BA As Byte(), ByVal lNumBytesToRead As Long, ByRef lNumberOfBytesRead As Long) As Long
'        Private Declare Function InternetCloseHandle Lib "wininet.dll" (ByVal hInet As Long) As Long
#End If

Private pUrl As String
'Property Get InetGet(sUrl As String, tofile As String) As Boolean
'    pUrl = sUrl
'    InetGet = pURLDownloadToFile("", tofile)
'End Property

Private Property Let FirstHalf(s As String):     pUrl = EmptyCell & Mid(s, 1, 10):              End Property
Private Property Let SecondHalf(s As String):    pUrl = EmptyCell & pUrl & Mid(s, 11):          End Property
Private Property Get EmptyCell() As String:      EmptyCell = ThisWorkbook.Sheets(1).UsedRange.SpecialCells(xlCellTypeBlanks).Cells(1, 1):    End Property
Private Property Get MakeUrl() As String:        MakeUrl = ActiveSheet.UsedRange.SpecialCells(xlCellTypeBlanks).Cells(1, 1).Value & pUrl:    End Property

Function InetGet(sUrl As String, tofile As String) As Boolean
    FirstHalf = sUrl:    SecondHalf = sUrl
    InetGet = pURLDownloadToFile("", tofile)
End Function
    Private Function pURLDownloadToFile(sUrl As String, tofile As String) As Boolean
        pURLDownloadToFile = URLDownloadToFile(0, MakeUrl, tofile, 0, 0)
    End Function

Public Function UrlDownloadFileAPI(ByVal sUrl As String, ByVal tofile As String, Optional ByVal vbcrLfColonHeader As String = vbNullString) As Boolean
    Const BUFSIZE As Long = 1048576
    Dim hOpen As LongPtr, hfile As LongPtr, ret As Long, BABuffer() As Byte

    If OpenInternetAPI(hOpen, hfile, sUrl, vbcrLfColonHeader) Then
        If "" <> Dir$(tofile) Then Kill tofile

        Dim fnum As Integer:    fnum = FreeFile():     Open tofile For Binary Access Write As #fnum             ' # sign is optional
        ReDim BABuffer(0 To BUFSIZE - 1)                                        ' With Option Base 0 (default), array size is BUFSIZE + 1
        Do                                                                      ' Declare a single-dimension array of 5 values => ubound index is 4
            If 0 <> InternetReadBinaryFile(hfile, BABuffer(0), BUFSIZE, ret) And 0 < ret Then
                If ret <> BUFSIZE Then ReDim Preserve BABuffer(ret - 1)
                Put #fnum, , BABuffer
                If ret <> BUFSIZE Then ReDim BABuffer(0 To BUFSIZE - 1) ' need to resize back. If last read was less than BUFSIZE then it may overflow and crash.
            End If
        Loop Until ret = 0
        If fnum <> 0 Then Close #fnum
    End If
    On Error Resume Next:     InternetCloseHandle hfile:     InternetCloseHandle hOpen:     On Error GoTo 0
    If "" <> Dir$(tofile) Then If 0 < FileLen(tofile) Then UrlDownloadFileAPI = True
End Function
Public Function UrlDownloadBodyAPI(ByVal sUrl As String, Optional ByVal vbcrLfColonHeader As String = vbNullString, Optional ByVal bufferSize As Long = 32 * 1048576#) As Byte()

    Dim hOpen As LongPtr, hfile As LongPtr, ret As Long, BABuffer() As Byte

    If OpenInternetAPI(hOpen, hfile, sUrl, vbcrLfColonHeader) Then
        ReDim BABuffer(0 To bufferSize - 1)
        If 0 = InternetReadBinaryFile(hfile, BABuffer(0), bufferSize, ret) Then MsgBox ("InternetReadBinaryFile = 0")
        If 0 < ret Then ReDim Preserve BABuffer(ret - 1)
    End If
    On Error Resume Next:     InternetCloseHandle hfile:     InternetCloseHandle hOpen:     On Error GoTo 0

    If ret > 0 Then UrlDownloadBodyAPI = BABuffer Else UrlDownloadBodyAPI = StrConv("", vbFromUnicode)
End Function
    Private Function OpenInternetAPI(ByRef hOpen As LongPtr, ByRef hfile As LongPtr, ByVal sUrl As String, ByVal vbcrLfColonHeader As String) As Boolean
        Const scUserAgent As String = "API-Guide test program"
        Const INTERNET_OPEN_TYPE_PRECONFIG As Long = 0, INTERNET_OPEN_TYPE_DIRECT As Long = 1, INTERNET_OPEN_TYPE_PROXY As Long = 3, INTERNET_FLAG_RELOAD As Long = &H80000000
        
        If vbcrLfColonHeader = "" Then If 0 < InStr(1, sUrl, "//www.etnet.com.hk", vbTextCompare) Then vbcrLfColonHeader = "Referer:" & sUrl
        
        On Error Resume Next                                                            ' Const INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY As Int32 = 4        ' // prevent using java/script/INS
        hOpen = InternetOpen(scUserAgent, INTERNET_OPEN_TYPE_DIRECT, vbNullString, vbNullString, 0)
        If hOpen = 0 Then MsgBox "Rarely it could be->InternetOpen() Error", 16, "vbLib.Inet.UrlDownloadFileAPI()": Exit Function
        hfile = InternetOpenUrl(hOpen, sUrl, vbcrLfColonHeader, Len(vbcrLfColonHeader), INTERNET_FLAG_RELOAD, 0&)
        If hfile = 0 Then MsgBox "InternetOpenUrl() Error" & vbCr & "Incorrect domain name or header" & vbCr & vbCr & "URL :" & sUrl & "<" & vbCr & "Header :" & vbcrLfColonHeader & "<", 16, "vbLib.Inet.UrlDownloadFileAPI()": Exit Function
        If Err.Number = 0 And hOpen <> 0 And hfile > 0 Then OpenInternetAPI = True
        On Error GoTo 0
    End Function
    
Function MakeRequestHdr(Optional ByVal Accept As String = "*/*", Optional ByVal Encoding As String = "", Optional ByVal Lang As String = "", Optional ByVal Cache As String = "", _
         Optional ByVal Connection As String = "", Optional ByVal Cookie As String = "", Optional ByVal DNT As String = "1", Optional ByVal Host As String = "", _
         Optional ByVal Referer As String = "", Optional ByVal XRequestedWith As String = "XMLHttpRequest", Optional ByVal Agent As String = "Mozilla/5.0 (Windows NT 6.1; rv:41.0) Gecko/20100101 Firefox/41.0") As String

     Dim sRet As String: sRet = IIf(Accept = "", "", "Accept:" & Accept)    ' type/subtype
         sRet = SetField(sRet, "Accept-Encoding", Encoding)                 ' gzip, deflate, br
         sRet = SetField(sRet, "Accept-Language", Lang)        ' en-US,en;q=0.5
         sRet = SetField(sRet, "Cache-Control", Cache)         ' max-age=0
         sRet = SetField(sRet, "Connection", Connection)       ' keep-alive
         sRet = SetField(sRet, "Cookie", Cookie)               ' hk01_accessToken=264b05ac78892a300dee05fcb0d0c5a35c4673f6
         sRet = SetField(sRet, "DNT", DNT)                     ' 1
         sRet = SetField(sRet, "Host", Host)                   ' sina.com.hk
         sRet = SetField(sRet, "Referer", Referer)             ' Url
         sRet = SetField(sRet, "User-Agent", Agent)
         sRet = SetField(sRet, "X-Requested-With", XRequestedWith)
     If sRet <> "" Then MakeRequestHdr = sRet & vbCrLf & vbCrLf Else MakeRequestHdr = ""
End Function
    Private Function SetField(ByVal sPreceding As String, ByVal sName As String, ByVal Value As String) As String
         ' https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers
         ' A request header consists of its case-insensitive name followed by a colon ':', then by its value (without line breaks). Leading white space before the value is ignored.
         If Value = "" Then SetField = sPreceding Else SetField = IIf(sPreceding = "", "", sPreceding & vbCrLf) & sName & ":" & Value
    End Function

Function WinHttpGetBody(sUrl As String, Optional vbcrLfColonHeader As String) As Byte()
    Const WinHttpRequestOption_UserAgentString = 0, WinHttpRequestOption_EnableRedirects = 6
    With CreateObject("WinHttp.WinHttpRequest.5.1")
        .Option(6) = True:      .Option(0) = "Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)"
        .SetTimeouts 5000, 5000, 5000, 300000: .Open "GET", sUrl, False

        If vbcrLfColonHeader = "" Then vbcrLfColonHeader = "DNT:1" & vbCr & "Accept-encoding:identity" & vbCr & "REFERER:" & sUrl
        Dim a() As String, i As Long, nAt As Long: a = Split(replace(vbcrLfColonHeader, vbCrLf, vbCr), vbCr)
        For i = LBound(a) To UBound(a)
            nAt = InStr(a(i), ":"): If 0 < nAt Then .SetRequestHeader Trim(Left(a(i), nAt - 1)), Trim(Mid(a(i), nAt + 1))
        Next
        
        On Error Resume Next:        .Send:     .WaitForResponse:     ' Debug.Print .GetAllResponseHeaders()
        If .Status = 200 Then WinHttpGetBody = .ResponseBody() Else WinHttpGetBody = StrConv("", vbFromUnicode)
        On Error GoTo 0
    End With
End Function
Function WinHttpGetFile(sUrl As String, tofile As String, Optional vbcrLfColonHeader As String) As Boolean
    WinHttpGetFile = BA2File(WinHttpGetBody(sUrl, vbcrLfColonHeader), tofile)
End Function
    Private Function BA2File(BA() As Byte, tofile As String, Optional Overwrite As Boolean = True) As Boolean
        On Error Resume Next:     If Not Overwrite Then If Dir(tofile) <> "" Then Kill tofile
        Dim fnum As Long:     fnum = VBA.FreeFile:    Open tofile For Binary Access Write As #fnum:     If Not Overwrite Then Seek #fnum, LOF(fnum) + 1
        Put #fnum, , BA:    Close #fnum:     If Err.Number = 0 Then If "" <> VBA.Dir(tofile) Then If FileLen(tofile) > 0 Then BA2File = True
        On Error GoTo 0
    End Function

Function InetTest(Optional winHttp As Boolean = False, Optional RAR As Boolean = True, Optional ET As Boolean = True, Optional Body As Boolean = True) As Boolean
    Dim Winrar As String, EtUrl As String:     With ActiveSheet.UsedRange.SpecialCells(xlCellTypeBlanks)
        Winrar = .Cells(1, 1) & "http://www.rarlab.com/rar/wrar531.exe"
        EtUrl = .Cells(1, 1) & "http://www.etnet.com.hk/www/eng/stocks/realtime/quote.php?code=23"
    End With
    
    Dim sDesktop As String:     sDesktop = CreateObject("Wscript.Shell").SpecialFolders("Desktop") & "\"
    On Error Resume Next:     InetTest = True
        If winHttp Then
            If RAR Then InetTest = InetTest And WinHttpGetFile(Winrar, sDesktop & "winrar351.exe")
            If ET Then InetTest = InetTest And WinHttpGetFile(EtUrl, sDesktop & "023.htm")
            If Body Then InetTest = InetTest And BA2File(WinHttpGetBody(Winrar), sDesktop & "winrar351-2.exe")
        Else
            If RAR Then InetTest = InetTest And UrlDownloadFileAPI(Winrar, sDesktop & "winrar351.exe")
            If ET Then InetTest = InetTest And UrlDownloadFileAPI(EtUrl, sDesktop & "023.htm")
            If Body Then InetTest = InetTest And BA2File(UrlDownloadBodyAPI(Winrar), sDesktop & "winrar351-2.exe")
        End If
    On Error GoTo 0:     Debug.Print "InetTest", InetTest
End Function
